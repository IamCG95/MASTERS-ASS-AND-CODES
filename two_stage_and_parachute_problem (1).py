# -*- coding: utf-8 -*-
"""Two stage  and parachute problem

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16KNNKxC1p2Gbt2kZZFUcRZ802Oi1fyv1
"""

### TWO STAGE TRANSPORTTAION PROBLEM

import numpy as np
import pandas as pd
from scipy.optimize import linprog

# Define supply, demand, and cost
ports = ['Vancouver', 'Boston', 'Miami', 'San Francisco'] #ports varaible
refineries = ['Denver', 'Atlanta', 'Pittsburgh'] #choice of location for refineries
outlets = ['Dallas', 'Phoenix', 'Portland', 'Montreal', 'Orlando'] # outlets for refined products

supply = {'Vancouver': 1000, 'Boston': 800, 'Miami': 800, 'San Francisco': 700}
demand = {'Dallas': 900, 'Phoenix': 800, 'Portland': 600, 'Montreal': 500, 'Orlando': 500}

# Costs from ports to refineries
port_to_refinery_costs = {
    ('Vancouver', 'Denver'): 4, ('Vancouver', 'Atlanta'): 13, ('Vancouver', 'Pittsburgh'): 9,
    ('Boston', 'Denver'): 8, ('Boston', 'Atlanta'): 8, ('Boston', 'Pittsburgh'): 5,
    ('Miami', 'Denver'): 12, ('Miami', 'Atlanta'): 2, ('Miami', 'Pittsburgh'): 9,
    ('San Francisco', 'Denver'): 11, ('San Francisco', 'Atlanta'): 11, ('San Francisco', 'Pittsburgh'): 12
}

# Costs from refineries to outlets
refinery_to_outlet_costs = {
    ('Denver', 'Dallas'): 28, ('Denver', 'Phoenix'): 26, ('Denver', 'Portland'): 12, ('Denver', 'Montreal'): 30, ('Denver', 'Orlando'): 30,
    ('Atlanta', 'Dallas'): 10, ('Atlanta', 'Phoenix'): 22, ('Atlanta', 'Portland'): 23, ('Atlanta', 'Montreal'): 29, ('Atlanta', 'Orlando'): 8,
    ('Pittsburgh', 'Dallas'): 18, ('Pittsburgh', 'Phoenix'): 21, ('Pittsburgh', 'Portland'): 23, ('Pittsburgh', 'Montreal'): 18, ('Pittsburgh', 'Orlando'): 21
}

# Create cost arrays for the linear programming problem
cost_port_to_refinery = np.array([port_to_refinery_costs[(p, r)] for p in ports for r in refineries])
cost_refinery_to_outlet = np.array([refinery_to_outlet_costs[(r, o)] for r in refineries for o in outlets])
costs = np.concatenate((cost_port_to_refinery, cost_refinery_to_outlet))

# Constraints matrix (equality) and vector
A_eq = []
b_eq = []

# Supply constraints for each port
for i, port in enumerate(ports):
    row = np.zeros(len(costs))
    for j, refinery in enumerate(refineries):
        row[i * len(refineries) + j] = 1
    A_eq.append(row)
    b_eq.append(supply[port])

# Demand constraints for each outlet
for i, outlet in enumerate(outlets):
    row = np.zeros(len(costs))
    for j, refinery in enumerate(refineries):
        row[len(cost_port_to_refinery) + j * len(outlets) + i] = 1
    A_eq.append(row)
    b_eq.append(demand[outlet])

A_eq = np.array(A_eq)
b_eq = np.array(b_eq)

# Solve the linear programming problem
result = linprog(c=costs, A_eq=A_eq, b_eq=b_eq, bounds=(0, None), method="highs")

# Results
total_cost = result.fun
shipment_values = result.x

# Organize results into DataFrames
port_to_refinery_df = pd.DataFrame({
    'Port': [port for port in ports for _ in refineries],
    'Refinery': refineries * len(ports),
    'Shipment': shipment_values[:len(cost_port_to_refinery)]
})

refinery_to_outlet_df = pd.DataFrame({
    'Refinery': [refinery for refinery in refineries for _ in outlets],
    'Outlet': outlets * len(refineries),
    'Shipment': shipment_values[len(cost_port_to_refinery):]
})

port_to_refinery_df, refinery_to_outlet_df, total_cost

from pulp import LpProblem, LpMinimize, LpVariable, lpSum, value
import pandas as pd

# Define data
ports = ['Vancouver', 'Boston', 'Miami', 'San Francisco']
refineries = ['Denver', 'Atlanta', 'Pittsburgh']
outlets = ['Dallas', 'Phoenix', 'Portland', 'Montreal', 'Orlando']

supply = {'Vancouver': 1000, 'Boston': 800, 'Miami': 800, 'San Francisco': 700}
demand = {'Dallas': 900, 'Phoenix': 800, 'Portland': 600, 'Montreal': 500, 'Orlando': 500}

port_to_refinery_costs = {
    ('Vancouver', 'Denver'): 4, ('Vancouver', 'Atlanta'): 13, ('Vancouver', 'Pittsburgh'): 9,
    ('Boston', 'Denver'): 8, ('Boston', 'Atlanta'): 8, ('Boston', 'Pittsburgh'): 5,
    ('Miami', 'Denver'): 12, ('Miami', 'Atlanta'): 2, ('Miami', 'Pittsburgh'): 9,
    ('San Francisco', 'Denver'): 11, ('San Francisco', 'Atlanta'): 11, ('San Francisco', 'Pittsburgh'): 12
}

refinery_to_outlet_costs = {
    ('Denver', 'Dallas'): 28, ('Denver', 'Phoenix'): 26, ('Denver', 'Portland'): 12, ('Denver', 'Montreal'): 30, ('Denver', 'Orlando'): 30,
    ('Atlanta', 'Dallas'): 10, ('Atlanta', 'Phoenix'): 22, ('Atlanta', 'Portland'): 23, ('Atlanta', 'Montreal'): 29, ('Atlanta', 'Orlando'): 8,
    ('Pittsburgh', 'Dallas'): 18, ('Pittsburgh', 'Phoenix'): 21, ('Pittsburgh', 'Portland'): 23, ('Pittsburgh', 'Montreal'): 18, ('Pittsburgh', 'Orlando'): 21
}

# Define the problem
prob = LpProblem("Two_Stage_Transportation", LpMinimize)

# Variables
port_to_refinery_vars = {
    (p, r): LpVariable(f"{p}_to_{r}", lowBound=0)
    for p in ports for r in refineries
}
refinery_to_outlet_vars = {
    (r, o): LpVariable(f"{r}_to_{o}", lowBound=0)
    for r in refineries for o in outlets
}

# Objective function
prob += lpSum(
    port_to_refinery_costs[(p, r)] * port_to_refinery_vars[(p, r)]
    for p in ports for r in refineries
) + lpSum(
    refinery_to_outlet_costs[(r, o)] * refinery_to_outlet_vars[(r, o)]
    for r in refineries for o in outlets
)

# Constraints
for p in ports:
    prob += lpSum(port_to_refinery_vars[(p, r)] for r in refineries) == supply[p]

for o in outlets:
    prob += lpSum(refinery_to_outlet_vars[(r, o)] for r in refineries) == demand[o]

for r in refineries:
    prob += (
        lpSum(port_to_refinery_vars[(p, r)] for p in ports)
        == lpSum(refinery_to_outlet_vars[(r, o)] for o in outlets)
    )

# Solve the problem
prob.solve()

# Results
port_to_refinery_df = pd.DataFrame([
    {"Port": p, "Refinery": r, "Shipment": value(port_to_refinery_vars[(p, r)])}
    for p in ports for r in refineries
])

refinery_to_outlet_df = pd.DataFrame([
    {"Refinery": r, "Outlet": o, "Shipment": value(refinery_to_outlet_vars[(r, o)])}
    for r in refineries for o in outlets
])

total_cost = value(prob.objective)

# Output results
print("Port to Refinery Shipments:")
print(port_to_refinery_df)
print("\nRefinery to Outlet Shipments:")
print(refinery_to_outlet_df)
print("\nTotal Transportation Cost:")
print(total_cost)

# Import necessary libraries
import numpy as np
import pandas as pd
from scipy.optimize import linprog

# Step 1: Define the locations
# Ports where raw materials are located
ports = ['Vancouver', 'Boston', 'Miami', 'San Francisco']

# Refineries where raw materials are processed
refineries = ['Denver', 'Atlanta', 'Pittsburgh']

# Outlets where processed materials are delivered
outlets = ['Dallas', 'Phoenix', 'Portland', 'Montreal', 'Orlando']

# Step 2: Define the supply and demand
# Supply available at each port
supply = {'Vancouver': 1000, 'Boston': 800, 'Miami': 800, 'San Francisco': 700}

# Demand required at each outlet
demand = {'Dallas': 900, 'Phoenix': 800, 'Portland': 600, 'Montreal': 500, 'Orlando': 500}

# Step 3: Define the costs
# Cost of transporting raw material from each port to each refinery
port_to_refinery_costs = {
    ('Vancouver', 'Denver'): 4, ('Vancouver', 'Atlanta'): 13, ('Vancouver', 'Pittsburgh'): 9,
    ('Boston', 'Denver'): 8, ('Boston', 'Atlanta'): 8, ('Boston', 'Pittsburgh'): 5,
    ('Miami', 'Denver'): 12, ('Miami', 'Atlanta'): 2, ('Miami', 'Pittsburgh'): 9,
    ('San Francisco', 'Denver'): 11, ('San Francisco', 'Atlanta'): 11, ('San Francisco', 'Pittsburgh'): 12
}

# Cost of transporting refined material from each refinery to each outlet
refinery_to_outlet_costs = {
    ('Denver', 'Dallas'): 28, ('Denver', 'Phoenix'): 26, ('Denver', 'Portland'): 12, ('Denver', 'Montreal'): 30, ('Denver', 'Orlando'): 30,
    ('Atlanta', 'Dallas'): 10, ('Atlanta', 'Phoenix'): 22, ('Atlanta', 'Portland'): 23, ('Atlanta', 'Montreal'): 29, ('Atlanta', 'Orlando'): 8,
    ('Pittsburgh', 'Dallas'): 18, ('Pittsburgh', 'Phoenix'): 21, ('Pittsburgh', 'Portland'): 23, ('Pittsburgh', 'Montreal'): 18, ('Pittsburgh', 'Orlando'): 21
}

# Step 4: Create a cost array
# Combine all costs into a single list
cost_port_to_refinery = [port_to_refinery_costs[(port, refinery)] for port in ports for refinery in refineries]
cost_refinery_to_outlet = [refinery_to_outlet_costs[(refinery, outlet)] for refinery in refineries for outlet in outlets]
total_costs = np.array(cost_port_to_refinery + cost_refinery_to_outlet)

# Step 5: Create constraints for the linear programming problem
# These constraints make sure supply and demand are met

# Initialize empty lists to store constraints
A_eq = []  # The coefficients matrix
b_eq = []  # The right-hand side values

# Supply constraints for each port
for port in ports:
    row = [0] * len(total_costs)  # Start with all zeros
    for i, refinery in enumerate(refineries):
        row[ports.index(port) * len(refineries) + i] = 1  # Add 1 for port-to-refinery routes
    A_eq.append(row)  # Add this row to the matrix
    b_eq.append(supply[port])  # Add the supply value to the RHS

# Demand constraints for each outlet
offset = len(cost_port_to_refinery)  # Offset for refinery-to-outlet costs
for outlet in outlets:
    row = [0] * len(total_costs)  # Start with all zeros
    for i, refinery in enumerate(refineries):
        row[offset + i * len(outlets) + outlets.index(outlet)] = 1  # Add 1 for refinery-to-outlet routes
    A_eq.append(row)  # Add this row to the matrix
    b_eq.append(demand[outlet])  # Add the demand value to the RHS

# Convert constraints to NumPy arrays
A_eq = np.array(A_eq)
b_eq = np.array(b_eq)

# Step 6: Solve the problem using linear programming
result = linprog(c=total_costs, A_eq=A_eq, b_eq=b_eq, bounds=(0, None), method="highs")

# Step 7: Extract the results
total_cost = result.fun  # Minimum transportation cost
shipments = result.x  # Optimal shipment amounts

# Step 8: Organize results into tables
# Shipments from ports to refineries
port_to_refinery_results = pd.DataFrame({
    'Port': [port for port in ports for _ in refineries],
    'Refinery': refineries * len(ports),
    'Shipment': shipments[:len(cost_port_to_refinery)]
})

# Shipments from refineries to outlets
refinery_to_outlet_results = pd.DataFrame({
    'Refinery': [refinery for refinery in refineries for _ in outlets],
    'Outlet': outlets * len(refineries),
    'Shipment': shipments[len(cost_port_to_refinery):]
})

# Step 9: Display the results
print("Shipments from Ports to Refineries:")
print(port_to_refinery_results)
print("\nShipments from Refineries to Outlets:")
print(refinery_to_outlet_results)
print(f"\nTotal Transportation Cost: {total_cost}")

# Calculate total supply and demand
total_supply = sum(supply.values())
total_demand = sum(demand.values())

# Check if the problem is balanced
is_balanced = total_supply == total_demand

total_supply, total_demand, is_balanced

import pandas as pd

# Village data with coordinates (x, y) and weights
villages = pd.DataFrame({
    'Village': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'x': [2, 2, 3, 5, 5, 7, 8, 9, 10, 11],
    'y': [8, 5, 2, 10, 6, 2, 8, 4, 7, 9],
    'Weight': [1] * 10
})

# Calculate weighted sums
villages['Weighted_x'] = villages['Weight'] * villages['x']
villages['Weighted_y'] = villages['Weight'] * villages['y']

# Sum of weights, weighted x and y values
total_weight = villages['Weight'].sum()
weighted_x_sum = villages['Weighted_x'].sum()
weighted_y_sum = villages['Weighted_y'].sum()

# Calculate weighted average (centroid)
weighted_avg_x = weighted_x_sum / total_weight
weighted_avg_y = weighted_y_sum / total_weight

# Drop point based on weighted average
weighted_drop_point = (round(weighted_avg_x), round(weighted_avg_y))

# Output statement with the optimal drop point
optimal_solution_statement = f"The optimal solution drop point for the parachute from the location data is {weighted_drop_point}."
optimal_solution_statement

# Re-import necessary packages and redefine the village data to ensure proper execution
# Drop off problem on parachute
import pandas as pd
from sklearn.cluster import KMeans
import os

# Set environment variable to suppress MKL memory leak warning on Windows
os.environ["OMP_NUM_THREADS"] = "1" # run this in cmd and anaconda powershell prompt  "set OMP_NUM_THREADS=1"

# Village data with coordinates (x, y) and weights
villages = pd.DataFrame({
    'Village': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'x': [2, 2, 3, 5, 5, 7, 8, 9, 10, 11],
    'y': [8, 5, 2, 10, 6, 2, 8, 4, 7, 9],
    'Weight': [1] * 10
})

# Calculate weighted values for x and y
villages['Weighted_x'] = villages['Weight'] * villages['x']
villages['Weighted_y'] = villages['Weight'] * villages['y']

# Perform k-means clustering to split villages into 2 clusters with explicit n_init to suppress warning
kmeans = KMeans(n_clusters=2, n_init=10, random_state=0).fit(villages[['x', 'y']])
villages['Cluster'] = kmeans.labels_

# Calculate weighted centroids for each cluster to find optimal drop points
drop_points = []
for cluster_id in range(2):
    cluster_villages = villages[villages['Cluster'] == cluster_id]
    total_weight = cluster_villages['Weight'].sum()
    weighted_x = (cluster_villages['Weighted_x'].sum() / total_weight)
    weighted_y = (cluster_villages['Weighted_y'].sum() / total_weight)
    drop_points.append((round(weighted_x), round(weighted_y)))

# Output statements for the drop points
drop_points_statement = f"The drop point for Parachute 1 is {drop_points[0]} and for Parachute 2 is {drop_points[1]}."
drop_points_statement

import matplotlib.pyplot as plt
import seaborn as sns

# Initialize plot
plt.figure(figsize=(8, 8))

# Plot villages
sns.scatterplot(x='x', y='y', data=villages, color='blue', s=100)
for i, (x, y) in enumerate(zip(villages['x'], villages['y']), start=1):
    plt.text(x + 0.2, y, str(i), color="blue", fontsize=10)

# Plot drop points
for i, (x, y) in enumerate(drop_points, start=1):
    plt.scatter(x, y, color='red', s=200, marker='X')
    plt.text(x + 0.2, y, f"Parachute {i}", color="red", fontsize=12)

# Set grid limits and labels
plt.xlim(0, 12)
plt.ylim(0, 12)
plt.xlabel("X Coordinate")
plt.ylabel("Y Coordinate")
plt.title("Village Locations and Parachute Drop Points")
plt.grid(True)
plt.show()