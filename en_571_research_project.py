# -*- coding: utf-8 -*-
"""EN 571 RESEARCH PROJECT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_lsLIAL3QBf9fImNtRzqTghSyaKhO-wz

# New section
"""

import numpy as np

# Define parameters
num_simulations = 10000
demand_data = {
    "probability": [0.40, 0.30, 0.30],
    "first_class_demand": [25, 12, 5],
    "business_class_demand": [60, 30, 9],
    "economy_class_demand": [210, 170, 150]
}
revenue = {"first_class": 1600, "business_class": 1100, "economy_class": 500}
seat_space = {"first_class": 2, "business_class": 1.5, "economy_class": 1}
total_capacity = 190

# Function to calculate revenue for a given allocation
def calculate_revenue(allocation, demand):
    seats_allocated = {
        "first_class": min(allocation["first_class"], demand["first_class"]),
        "business_class": min(allocation["business_class"], demand["business_class"]),
        "economy_class": min(allocation["economy_class"], demand["economy_class"])
    }
    total_revenue = (
        seats_allocated["first_class"] * revenue["first_class"] +
        seats_allocated["business_class"] * revenue["business_class"] +
        seats_allocated["economy_class"] * revenue["economy_class"]
    )
    return total_revenue

# Monte Carlo simulation
results = []
for _ in range(num_simulations):
    # Randomly select demand scenario
    demand_index = np.random.choice([0, 1, 2], p=demand_data["probability"])
    demand = {
        "first_class": demand_data["first_class_demand"][demand_index],
        "business_class": demand_data["business_class_demand"][demand_index],
        "economy_class": demand_data["economy_class_demand"][demand_index]
    }

    # Try different seat allocations to maximize revenue within capacity constraints
    best_revenue = 0
    for first_class_seats in range(0, total_capacity // int(seat_space["first_class"]) + 1):
        for business_class_seats in range(0, total_capacity // int(seat_space["business_class"]) + 1):
            economy_seats = total_capacity - (
                first_class_seats * seat_space["first_class"] +
                business_class_seats * seat_space["business_class"]
            )

            if economy_seats >= 0:
                allocation = {
                    "first_class": first_class_seats,
                    "business_class": business_class_seats,
                    "economy_class": int(economy_seats)
                }
                current_revenue = calculate_revenue(allocation, demand)

                if current_revenue > best_revenue:
                    best_revenue = current_revenue

    results.append(best_revenue)

# Calculating the expected revenue from simulations
expected_revenue = np.mean(results)
print("Expected Revenue:", expected_revenue)

import pulp

# Define the problem
prob = pulp.LpProblem("Maximize_Airline_Revenue", pulp.LpMaximize)

# Decision variables
x_F = pulp.LpVariable('x_F', lowBound=0, cat='Continuous')  # first-class seats
x_B = pulp.LpVariable('x_B', lowBound=0, cat='Continuous')  # business-class seats
x_E = pulp.LpVariable('x_E', lowBound=0, cat='Continuous')  # economy-class seats

# Objective function: Expected revenue
prob += (0.4 * (1600 * x_F + 1100 * x_B + 500 * x_E) +
         0.3 * (1600 * x_F + 1100 * x_B + 500 * x_E) +
         0.3 * (1600 * x_F + 1100 * x_B + 500 * x_E)), "Expected_Revenue"

# Constraints: Ensure the number of seats allocated does not exceed the available space
prob += 2 * x_F + 1.5 * x_B + x_E <= 190, "Space_Constraint"

# Demand constraints: Based on the highest demand scenario
prob += x_F <= 25, "First_Class_Demand"
prob += x_B <= 60, "Business_Class_Demand"
prob += x_E <= 210, "Economy_Class_Demand"

# Solve the problem
prob.solve()

# Output the results
print("Status:", pulp.LpStatus[prob.status])
print("Optimal number of first-class seats:", pulp.value(x_F))
print("Optimal number of business-class seats:", pulp.value(x_B))
print("Optimal number of economy-class seats:", pulp.value(x_E))
print("Maximum Expected Revenue:", pulp.value(prob.objective))